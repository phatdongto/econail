{"ast":null,"code":"var _class, _temp;\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar _require = require('@uppy/core'),\n    Plugin = _require.Plugin;\n\nvar tus = require('tus-js-client');\n\nvar _require2 = require('@uppy/companion-client'),\n    Provider = _require2.Provider,\n    RequestClient = _require2.RequestClient,\n    Socket = _require2.Socket;\n\nvar emitSocketProgress = require('@uppy/utils/lib/emitSocketProgress');\n\nvar getSocketHost = require('@uppy/utils/lib/getSocketHost');\n\nvar settle = require('@uppy/utils/lib/settle');\n\nvar EventTracker = require('@uppy/utils/lib/EventTracker');\n\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\n\nvar isNetworkError = require('@uppy/utils/lib/isNetworkError');\n\nvar RateLimitedQueue = require('@uppy/utils/lib/RateLimitedQueue');\n\nvar hasProperty = require('@uppy/utils/lib/hasProperty');\n\nvar getFingerprint = require('./getFingerprint');\n/** @typedef {import('..').TusOptions} TusOptions */\n\n/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */\n\n/** @typedef {import('@uppy/core').Uppy} Uppy */\n\n/** @typedef {import('@uppy/core').UppyFile} UppyFile */\n\n/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */\n\n/**\n * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13\n * excepted we removed 'fingerprint' key to avoid adding more dependencies\n *\n * @type {RawTusOptions}\n */\n\n\nvar tusDefaultOptions = {\n  endpoint: '',\n  uploadUrl: null,\n  metadata: {},\n  uploadSize: null,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n  chunkSize: Infinity,\n  retryDelays: [0, 1000, 3000, 5000],\n  parallelUploads: 1,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false\n};\n/**\n * Tus resumable file uploader\n */\n\nmodule.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {\n  _inheritsLoose(Tus, _Plugin);\n  /**\n   * @param {Uppy} uppy\n   * @param {TusOptions} opts\n   */\n\n\n  function Tus(uppy, opts) {\n    var _this;\n\n    _this = _Plugin.call(this, uppy, opts) || this;\n    _this.type = 'uploader';\n    _this.id = _this.opts.id || 'Tus';\n    _this.title = 'Tus'; // set default options\n\n    var defaultOptions = {\n      autoRetry: true,\n      resume: true,\n      useFastRemoteRetry: true,\n      limit: 0,\n      retryDelays: [0, 1000, 3000, 5000],\n      withCredentials: false\n    }; // merge default options with the ones set by user\n\n    /** @type {import(\"..\").TusOptions} */\n\n    _this.opts = _extends({}, defaultOptions, opts);\n    /**\n     * Simultaneous upload limiting is shared across all uploads with this plugin.\n     *\n     * @type {RateLimitedQueue}\n     */\n\n    _this.requests = new RateLimitedQueue(_this.opts.limit);\n    _this.uploaders = Object.create(null);\n    _this.uploaderEvents = Object.create(null);\n    _this.uploaderSockets = Object.create(null);\n    _this.handleResetProgress = _this.handleResetProgress.bind(_assertThisInitialized(_this));\n    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = Tus.prototype;\n\n  _proto.handleResetProgress = function handleResetProgress() {\n    var files = _extends({}, this.uppy.getState().files);\n\n    Object.keys(files).forEach(function (fileID) {\n      // Only clone the file object if it has a Tus `uploadUrl` attached.\n      if (files[fileID].tus && files[fileID].tus.uploadUrl) {\n        var tusState = _extends({}, files[fileID].tus);\n\n        delete tusState.uploadUrl;\n        files[fileID] = _extends({}, files[fileID], {\n          tus: tusState\n        });\n      }\n    });\n    this.uppy.setState({\n      files: files\n    });\n  }\n  /**\n   * Clean up all references for a file's upload: the tus.Upload instance,\n   * any events related to the file, and the Companion WebSocket connection.\n   *\n   * @param {string} fileID\n   */\n  ;\n\n  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (this.uploaders[fileID]) {\n      var uploader = this.uploaders[fileID];\n      uploader.abort();\n\n      if (opts.abort) {\n        // to avoid 423 error from tus server, we wait\n        // to be sure the previous request has been aborted before terminating the upload\n        // @todo remove the timeout when this \"wait\" is handled in tus-js-client internally\n        setTimeout(function () {\n          return uploader.abort(true);\n        }, 1000);\n      }\n\n      this.uploaders[fileID] = null;\n    }\n\n    if (this.uploaderEvents[fileID]) {\n      this.uploaderEvents[fileID].remove();\n      this.uploaderEvents[fileID] = null;\n    }\n\n    if (this.uploaderSockets[fileID]) {\n      this.uploaderSockets[fileID].close();\n      this.uploaderSockets[fileID] = null;\n    }\n  }\n  /**\n   * Create a new Tus upload.\n   *\n   * A lot can happen during an upload, so this is quite hard to follow!\n   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.\n   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.\n   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners\n   *   for pausing, cancellation, removal, etc.\n   * - While the upload is in progress, it may be paused or cancelled.\n   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is\n   *   maintained.\n   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload--the tus.Upload instance\n   *   is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).\n   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from\n   *   bypassing the limit.\n   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done\n   *   in the `this.requests` queue.\n   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is rejected.\n   *\n   * When working on this function, keep in mind:\n   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned up using this.resetUploaderReferences().\n   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using `queuedRequest.abort()`.\n   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using `queuedRequest.done()`.\n   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable must be updated so the other uses of it are valid.\n   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking up a spot in the queue.\n   *\n   * @param {UppyFile} file for use with upload\n   * @param {number} current file in a queue\n   * @param {number} total number of files in a queue\n   * @returns {Promise<void>}\n   */\n  ;\n\n  _proto.upload = function upload(file, current, total) {\n    var _this2 = this;\n\n    this.resetUploaderReferences(file.id); // Create a new tus upload\n\n    return new Promise(function (resolve, reject) {\n      _this2.uppy.emit('upload-started', file);\n\n      var opts = _extends({}, _this2.opts, file.tus || {});\n      /** @type {RawTusOptions} */\n\n\n      var uploadOptions = _extends({}, tusDefaultOptions, opts);\n\n      delete uploadOptions.resume; // Make `resume: true` work like it did in tus-js-client v1.\n      // TODO: Remove in @uppy/tus v2\n\n      if (opts.resume) {\n        uploadOptions.storeFingerprintForResuming = true;\n      } // We override tus fingerprint to uppy’s `file.id`, since the `file.id`\n      // now also includes `relativePath` for files added from folders.\n      // This means you can add 2 identical files, if one is in folder a,\n      // the other in folder b.\n\n\n      uploadOptions.fingerprint = getFingerprint(file);\n\n      uploadOptions.onBeforeRequest = function (req) {\n        var xhr = req.getUnderlyingObject();\n        xhr.withCredentials = !!opts.withCredentials;\n\n        if (typeof opts.onBeforeRequest === 'function') {\n          opts.onBeforeRequest(req);\n        }\n      };\n\n      uploadOptions.onError = function (err) {\n        _this2.uppy.log(err);\n\n        var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;\n\n        if (isNetworkError(xhr)) {\n          err = new NetworkError(err, xhr);\n        }\n\n        _this2.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n\n        _this2.uppy.emit('upload-error', file, err);\n\n        reject(err);\n      };\n\n      uploadOptions.onProgress = function (bytesUploaded, bytesTotal) {\n        _this2.onReceiveUploadUrl(file, upload.url);\n\n        _this2.uppy.emit('upload-progress', file, {\n          uploader: _this2,\n          bytesUploaded: bytesUploaded,\n          bytesTotal: bytesTotal\n        });\n      };\n\n      uploadOptions.onSuccess = function () {\n        var uploadResp = {\n          uploadURL: upload.url\n        };\n\n        _this2.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n\n        _this2.uppy.emit('upload-success', file, uploadResp);\n\n        if (upload.url) {\n          _this2.uppy.log(\"Download \" + upload.file.name + \" from \" + upload.url);\n        }\n\n        resolve(upload);\n      };\n\n      var copyProp = function copyProp(obj, srcProp, destProp) {\n        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {\n          obj[destProp] = obj[srcProp];\n        }\n      };\n      /** @type {Record<string, string>} */\n\n\n      var meta = {};\n      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.\n      : Object.keys(file.meta);\n      metaFields.forEach(function (item) {\n        meta[item] = file.meta[item];\n      }); // tusd uses metadata fields 'filetype' and 'filename'\n\n      copyProp(meta, 'type', 'filetype');\n      copyProp(meta, 'name', 'filename');\n      uploadOptions.metadata = meta;\n      var upload = new tus.Upload(file.data, uploadOptions);\n      _this2.uploaders[file.id] = upload;\n      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy); // Make `resume: true` work like it did in tus-js-client v1.\n      // TODO: Remove in @uppy/tus v2.\n\n      if (opts.resume) {\n        upload.findPreviousUploads().then(function (previousUploads) {\n          var previousUpload = previousUploads[0];\n\n          if (previousUpload) {\n            _this2.uppy.log(\"[Tus] Resuming upload of \" + file.id + \" started at \" + previousUpload.creationTime);\n\n            upload.resumeFromPreviousUpload(previousUpload);\n          }\n        });\n      }\n\n      var queuedRequest = _this2.requests.run(function () {\n        if (!file.isPaused) {\n          // Ensure this gets scheduled to run _after_ `findPreviousUploads()` returns.\n          // TODO: Remove in @uppy/tus v2.\n          Promise.resolve().then(function () {\n            upload.start();\n          });\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n\n\n        return function () {};\n      });\n\n      _this2.onFileRemove(file.id, function (targetFileID) {\n        queuedRequest.abort();\n\n        _this2.resetUploaderReferences(file.id, {\n          abort: !!upload.url\n        });\n\n        resolve(\"upload \" + targetFileID + \" was removed\");\n      });\n\n      _this2.onPause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          upload.abort();\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this2.requests.run(function () {\n            upload.start();\n            return function () {};\n          });\n        }\n      });\n\n      _this2.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        upload.abort();\n      });\n\n      _this2.onCancelAll(file.id, function () {\n        queuedRequest.abort();\n\n        _this2.resetUploaderReferences(file.id, {\n          abort: !!upload.url\n        });\n\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n\n      _this2.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n\n        if (file.error) {\n          upload.abort();\n        }\n\n        queuedRequest = _this2.requests.run(function () {\n          upload.start();\n          return function () {};\n        });\n      });\n    }).catch(function (err) {\n      _this2.uppy.emit('upload-error', file, err);\n\n      throw err;\n    });\n  }\n  /**\n   * @param {UppyFile} file for use with upload\n   * @param {number} current file in a queue\n   * @param {number} total number of files in a queue\n   * @returns {Promise<void>}\n   */\n  ;\n\n  _proto.uploadRemote = function uploadRemote(file, current, total) {\n    var _this3 = this;\n\n    this.resetUploaderReferences(file.id);\n\n    var opts = _extends({}, this.opts);\n\n    if (file.tus) {\n      // Install file-specific upload overrides.\n      _extends(opts, file.tus);\n    }\n\n    this.uppy.emit('upload-started', file);\n    this.uppy.log(file.remote.url);\n\n    if (file.serverToken) {\n      return this.connectToServerSocket(file);\n    }\n\n    return new Promise(function (resolve, reject) {\n      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n      var client = new Client(_this3.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet\n\n      client.post(file.remote.url, _extends({}, file.remote.body, {\n        endpoint: opts.endpoint,\n        uploadUrl: opts.uploadUrl,\n        protocol: 'tus',\n        size: file.data.size,\n        headers: opts.headers,\n        metadata: file.meta\n      })).then(function (res) {\n        _this3.uppy.setFileState(file.id, {\n          serverToken: res.token\n        });\n\n        file = _this3.uppy.getFile(file.id);\n        return _this3.connectToServerSocket(file);\n      }).then(function () {\n        resolve();\n      }).catch(function (err) {\n        _this3.uppy.emit('upload-error', file, err);\n\n        reject(err);\n      });\n    });\n  }\n  /**\n   * See the comment on the upload() method.\n   *\n   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().\n   *\n   * @param {UppyFile} file\n   */\n  ;\n\n  _proto.connectToServerSocket = function connectToServerSocket(file) {\n    var _this4 = this;\n\n    return new Promise(function (resolve, reject) {\n      var token = file.serverToken;\n      var host = getSocketHost(file.remote.companionUrl);\n      var socket = new Socket({\n        target: host + \"/api/\" + token,\n        autoOpen: false\n      });\n      _this4.uploaderSockets[file.id] = socket;\n      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);\n\n      _this4.onFileRemove(file.id, function () {\n        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion\n        // @todo don't send pause event in the next major release.\n\n        socket.send('pause', {});\n        socket.send('cancel', {});\n\n        _this4.resetUploaderReferences(file.id);\n\n        resolve(\"upload \" + file.id + \" was removed\");\n      });\n\n      _this4.onPause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          socket.send('pause', {});\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this4.requests.run(function () {\n            socket.send('resume', {});\n            return function () {};\n          });\n        }\n      });\n\n      _this4.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        socket.send('pause', {});\n      });\n\n      _this4.onCancelAll(file.id, function () {\n        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion\n        // @todo don't send pause event in the next major release.\n\n        socket.send('pause', {});\n        socket.send('cancel', {});\n\n        _this4.resetUploaderReferences(file.id);\n\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n\n      _this4.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n\n        if (file.error) {\n          socket.send('pause', {});\n        }\n\n        queuedRequest = _this4.requests.run(function () {\n          socket.send('resume', {});\n          return function () {};\n        });\n      });\n\n      _this4.onRetry(file.id, function () {\n        // Only do the retry if the upload is actually in progress;\n        // else we could try to send these messages when the upload is still queued.\n        // We may need a better check for this since the socket may also be closed\n        // for other reasons, like network failures.\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n\n      _this4.onRetryAll(file.id, function () {\n        // See the comment in the onRetry() call\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n\n      socket.on('progress', function (progressData) {\n        return emitSocketProgress(_this4, progressData, file);\n      });\n      socket.on('error', function (errData) {\n        var message = errData.error.message;\n\n        var error = _extends(new Error(message), {\n          cause: errData.error\n        }); // If the remote retry optimisation should not be used,\n        // close the socket—this will tell companion to clear state and delete the file.\n\n\n        if (!_this4.opts.useFastRemoteRetry) {\n          _this4.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.\n\n\n          _this4.uppy.setFileState(file.id, {\n            serverToken: null\n          });\n        } else {\n          socket.close();\n        }\n\n        _this4.uppy.emit('upload-error', file, error);\n\n        queuedRequest.done();\n        reject(error);\n      });\n      socket.on('success', function (data) {\n        var uploadResp = {\n          uploadURL: data.url\n        };\n\n        _this4.uppy.emit('upload-success', file, uploadResp);\n\n        _this4.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n        resolve();\n      });\n\n      var queuedRequest = _this4.requests.run(function () {\n        socket.open();\n\n        if (file.isPaused) {\n          socket.send('pause', {});\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n\n\n        return function () {};\n      });\n    });\n  }\n  /**\n   * Store the uploadUrl on the file options, so that when Golden Retriever\n   * restores state, we will continue uploading to the correct URL.\n   *\n   * @param {UppyFile} file\n   * @param {string} uploadURL\n   */\n  ;\n\n  _proto.onReceiveUploadUrl = function onReceiveUploadUrl(file, uploadURL) {\n    var currentFile = this.uppy.getFile(file.id);\n    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.\n\n    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {\n      this.uppy.log('[Tus] Storing upload url');\n      this.uppy.setFileState(currentFile.id, {\n        tus: _extends({}, currentFile.tus, {\n          uploadUrl: uploadURL\n        })\n      });\n    }\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(string): void} cb\n   */\n  ;\n\n  _proto.onFileRemove = function onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', function (file) {\n      if (fileID === file.id) cb(file.id);\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(boolean): void} cb\n   */\n  ;\n\n  _proto.onPause = function onPause(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {\n      if (fileID === targetFileID) {\n        // const isPaused = this.uppy.pauseResume(fileID)\n        cb(isPaused);\n      }\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onRetry = function onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onRetryAll = function onRetryAll(fileID, cb) {\n    var _this5 = this;\n\n    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {\n      if (!_this5.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onPauseAll = function onPauseAll(fileID, cb) {\n    var _this6 = this;\n\n    this.uploaderEvents[fileID].on('pause-all', function () {\n      if (!_this6.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onCancelAll = function onCancelAll(fileID, cb) {\n    var _this7 = this;\n\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this7.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onResumeAll = function onResumeAll(fileID, cb) {\n    var _this8 = this;\n\n    this.uploaderEvents[fileID].on('resume-all', function () {\n      if (!_this8.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {(UppyFile | FailedUppyFile)[]} files\n   */\n  ;\n\n  _proto.uploadFiles = function uploadFiles(files) {\n    var _this9 = this;\n\n    var promises = files.map(function (file, i) {\n      var current = i + 1;\n      var total = files.length;\n\n      if ('error' in file && file.error) {\n        return Promise.reject(new Error(file.error));\n      }\n\n      if (file.isRemote) {\n        // We emit upload-started here, so that it's also emitted for files\n        // that have to wait due to the `limit` option.\n        // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n        if (!file.progress.uploadStarted || !file.isRestored) {\n          _this9.uppy.emit('upload-started', file);\n        }\n\n        return _this9.uploadRemote(file, current, total);\n      } // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n\n\n      if (!file.progress.uploadStarted || !file.isRestored) {\n        _this9.uppy.emit('upload-started', file);\n      }\n\n      return _this9.upload(file, current, total);\n    });\n    return settle(promises);\n  }\n  /**\n   * @param {string[]} fileIDs\n   */\n  ;\n\n  _proto.handleUpload = function handleUpload(fileIDs) {\n    var _this10 = this;\n\n    if (fileIDs.length === 0) {\n      this.uppy.log('[Tus] No files to upload');\n      return Promise.resolve();\n    }\n\n    if (this.opts.limit === 0) {\n      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');\n    }\n\n    this.uppy.log('[Tus] Uploading...');\n    var filesToUpload = fileIDs.map(function (fileID) {\n      return _this10.uppy.getFile(fileID);\n    });\n    return this.uploadFiles(filesToUpload).then(function () {\n      return null;\n    });\n  };\n\n  _proto.install = function install() {\n    this.uppy.setState({\n      capabilities: _extends({}, this.uppy.getState().capabilities, {\n        resumableUploads: true\n      })\n    });\n    this.uppy.addUploader(this.handleUpload);\n    this.uppy.on('reset-progress', this.handleResetProgress);\n\n    if (this.opts.autoRetry) {\n      this.uppy.on('back-online', this.uppy.retryAll);\n    }\n  };\n\n  _proto.uninstall = function uninstall() {\n    this.uppy.setState({\n      capabilities: _extends({}, this.uppy.getState().capabilities, {\n        resumableUploads: false\n      })\n    });\n    this.uppy.removeUploader(this.handleUpload);\n\n    if (this.opts.autoRetry) {\n      this.uppy.off('back-online', this.uppy.retryAll);\n    }\n  };\n\n  return Tus;\n}(Plugin), _class.VERSION = \"1.9.1\", _temp);","map":{"version":3,"sources":["D:/Team6-FE/isomorphic/node_modules/@uppy/tus/lib/index.js"],"names":["_class","_temp","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_assertThisInitialized","self","ReferenceError","_inheritsLoose","subClass","superClass","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_require","require","Plugin","tus","_require2","Provider","RequestClient","Socket","emitSocketProgress","getSocketHost","settle","EventTracker","NetworkError","isNetworkError","RateLimitedQueue","hasProperty","getFingerprint","tusDefaultOptions","endpoint","uploadUrl","metadata","uploadSize","onProgress","onChunkComplete","onSuccess","onError","overridePatchMethod","headers","addRequestId","chunkSize","Infinity","retryDelays","parallelUploads","storeFingerprintForResuming","removeFingerprintOnSuccess","uploadLengthDeferred","uploadDataDuringCreation","module","exports","_Plugin","Tus","uppy","opts","_this","type","id","title","defaultOptions","autoRetry","resume","useFastRemoteRetry","limit","withCredentials","requests","uploaders","uploaderEvents","uploaderSockets","handleResetProgress","bind","handleUpload","_proto","files","getState","keys","forEach","fileID","tusState","setState","resetUploaderReferences","uploader","abort","setTimeout","remove","close","upload","file","current","total","_this2","Promise","resolve","reject","emit","uploadOptions","fingerprint","onBeforeRequest","req","xhr","getUnderlyingObject","err","log","originalRequest","queuedRequest","done","bytesUploaded","bytesTotal","onReceiveUploadUrl","url","uploadResp","uploadURL","name","copyProp","obj","srcProp","destProp","meta","metaFields","Array","isArray","item","Upload","data","findPreviousUploads","then","previousUploads","previousUpload","creationTime","resumeFromPreviousUpload","run","isPaused","start","onFileRemove","targetFileID","onPause","onPauseAll","onCancelAll","onResumeAll","error","catch","uploadRemote","_this3","remote","serverToken","connectToServerSocket","Client","providerOptions","provider","client","post","body","protocol","size","res","setFileState","token","getFile","_this4","host","companionUrl","socket","autoOpen","send","onRetry","isOpen","onRetryAll","on","progressData","errData","message","Error","cause","open","currentFile","cb","_this5","filesToRetry","_this6","_this7","_this8","uploadFiles","_this9","promises","map","isRemote","progress","uploadStarted","isRestored","fileIDs","_this10","filesToUpload","install","capabilities","resumableUploads","addUploader","retryAll","uninstall","removeUploader","off","VERSION"],"mappings":"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","sourcesContent":["var _class, _temp;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar _require = require('@uppy/core'),\n    Plugin = _require.Plugin;\n\nvar tus = require('tus-js-client');\n\nvar _require2 = require('@uppy/companion-client'),\n    Provider = _require2.Provider,\n    RequestClient = _require2.RequestClient,\n    Socket = _require2.Socket;\n\nvar emitSocketProgress = require('@uppy/utils/lib/emitSocketProgress');\n\nvar getSocketHost = require('@uppy/utils/lib/getSocketHost');\n\nvar settle = require('@uppy/utils/lib/settle');\n\nvar EventTracker = require('@uppy/utils/lib/EventTracker');\n\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\n\nvar isNetworkError = require('@uppy/utils/lib/isNetworkError');\n\nvar RateLimitedQueue = require('@uppy/utils/lib/RateLimitedQueue');\n\nvar hasProperty = require('@uppy/utils/lib/hasProperty');\n\nvar getFingerprint = require('./getFingerprint');\n/** @typedef {import('..').TusOptions} TusOptions */\n\n/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */\n\n/** @typedef {import('@uppy/core').Uppy} Uppy */\n\n/** @typedef {import('@uppy/core').UppyFile} UppyFile */\n\n/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */\n\n/**\n * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13\n * excepted we removed 'fingerprint' key to avoid adding more dependencies\n *\n * @type {RawTusOptions}\n */\n\n\nvar tusDefaultOptions = {\n  endpoint: '',\n  uploadUrl: null,\n  metadata: {},\n  uploadSize: null,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n  chunkSize: Infinity,\n  retryDelays: [0, 1000, 3000, 5000],\n  parallelUploads: 1,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false\n};\n/**\n * Tus resumable file uploader\n */\n\nmodule.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {\n  _inheritsLoose(Tus, _Plugin);\n\n  /**\n   * @param {Uppy} uppy\n   * @param {TusOptions} opts\n   */\n  function Tus(uppy, opts) {\n    var _this;\n\n    _this = _Plugin.call(this, uppy, opts) || this;\n    _this.type = 'uploader';\n    _this.id = _this.opts.id || 'Tus';\n    _this.title = 'Tus'; // set default options\n\n    var defaultOptions = {\n      autoRetry: true,\n      resume: true,\n      useFastRemoteRetry: true,\n      limit: 0,\n      retryDelays: [0, 1000, 3000, 5000],\n      withCredentials: false\n    }; // merge default options with the ones set by user\n\n    /** @type {import(\"..\").TusOptions} */\n\n    _this.opts = _extends({}, defaultOptions, opts);\n    /**\n     * Simultaneous upload limiting is shared across all uploads with this plugin.\n     *\n     * @type {RateLimitedQueue}\n     */\n\n    _this.requests = new RateLimitedQueue(_this.opts.limit);\n    _this.uploaders = Object.create(null);\n    _this.uploaderEvents = Object.create(null);\n    _this.uploaderSockets = Object.create(null);\n    _this.handleResetProgress = _this.handleResetProgress.bind(_assertThisInitialized(_this));\n    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = Tus.prototype;\n\n  _proto.handleResetProgress = function handleResetProgress() {\n    var files = _extends({}, this.uppy.getState().files);\n\n    Object.keys(files).forEach(function (fileID) {\n      // Only clone the file object if it has a Tus `uploadUrl` attached.\n      if (files[fileID].tus && files[fileID].tus.uploadUrl) {\n        var tusState = _extends({}, files[fileID].tus);\n\n        delete tusState.uploadUrl;\n        files[fileID] = _extends({}, files[fileID], {\n          tus: tusState\n        });\n      }\n    });\n    this.uppy.setState({\n      files: files\n    });\n  }\n  /**\n   * Clean up all references for a file's upload: the tus.Upload instance,\n   * any events related to the file, and the Companion WebSocket connection.\n   *\n   * @param {string} fileID\n   */\n  ;\n\n  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (this.uploaders[fileID]) {\n      var uploader = this.uploaders[fileID];\n      uploader.abort();\n\n      if (opts.abort) {\n        // to avoid 423 error from tus server, we wait\n        // to be sure the previous request has been aborted before terminating the upload\n        // @todo remove the timeout when this \"wait\" is handled in tus-js-client internally\n        setTimeout(function () {\n          return uploader.abort(true);\n        }, 1000);\n      }\n\n      this.uploaders[fileID] = null;\n    }\n\n    if (this.uploaderEvents[fileID]) {\n      this.uploaderEvents[fileID].remove();\n      this.uploaderEvents[fileID] = null;\n    }\n\n    if (this.uploaderSockets[fileID]) {\n      this.uploaderSockets[fileID].close();\n      this.uploaderSockets[fileID] = null;\n    }\n  }\n  /**\n   * Create a new Tus upload.\n   *\n   * A lot can happen during an upload, so this is quite hard to follow!\n   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.\n   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.\n   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners\n   *   for pausing, cancellation, removal, etc.\n   * - While the upload is in progress, it may be paused or cancelled.\n   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is\n   *   maintained.\n   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload--the tus.Upload instance\n   *   is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).\n   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from\n   *   bypassing the limit.\n   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done\n   *   in the `this.requests` queue.\n   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is rejected.\n   *\n   * When working on this function, keep in mind:\n   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned up using this.resetUploaderReferences().\n   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using `queuedRequest.abort()`.\n   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using `queuedRequest.done()`.\n   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable must be updated so the other uses of it are valid.\n   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking up a spot in the queue.\n   *\n   * @param {UppyFile} file for use with upload\n   * @param {number} current file in a queue\n   * @param {number} total number of files in a queue\n   * @returns {Promise<void>}\n   */\n  ;\n\n  _proto.upload = function upload(file, current, total) {\n    var _this2 = this;\n\n    this.resetUploaderReferences(file.id); // Create a new tus upload\n\n    return new Promise(function (resolve, reject) {\n      _this2.uppy.emit('upload-started', file);\n\n      var opts = _extends({}, _this2.opts, file.tus || {});\n      /** @type {RawTusOptions} */\n\n\n      var uploadOptions = _extends({}, tusDefaultOptions, opts);\n\n      delete uploadOptions.resume; // Make `resume: true` work like it did in tus-js-client v1.\n      // TODO: Remove in @uppy/tus v2\n\n      if (opts.resume) {\n        uploadOptions.storeFingerprintForResuming = true;\n      } // We override tus fingerprint to uppy’s `file.id`, since the `file.id`\n      // now also includes `relativePath` for files added from folders.\n      // This means you can add 2 identical files, if one is in folder a,\n      // the other in folder b.\n\n\n      uploadOptions.fingerprint = getFingerprint(file);\n\n      uploadOptions.onBeforeRequest = function (req) {\n        var xhr = req.getUnderlyingObject();\n        xhr.withCredentials = !!opts.withCredentials;\n\n        if (typeof opts.onBeforeRequest === 'function') {\n          opts.onBeforeRequest(req);\n        }\n      };\n\n      uploadOptions.onError = function (err) {\n        _this2.uppy.log(err);\n\n        var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;\n\n        if (isNetworkError(xhr)) {\n          err = new NetworkError(err, xhr);\n        }\n\n        _this2.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n\n        _this2.uppy.emit('upload-error', file, err);\n\n        reject(err);\n      };\n\n      uploadOptions.onProgress = function (bytesUploaded, bytesTotal) {\n        _this2.onReceiveUploadUrl(file, upload.url);\n\n        _this2.uppy.emit('upload-progress', file, {\n          uploader: _this2,\n          bytesUploaded: bytesUploaded,\n          bytesTotal: bytesTotal\n        });\n      };\n\n      uploadOptions.onSuccess = function () {\n        var uploadResp = {\n          uploadURL: upload.url\n        };\n\n        _this2.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n\n        _this2.uppy.emit('upload-success', file, uploadResp);\n\n        if (upload.url) {\n          _this2.uppy.log(\"Download \" + upload.file.name + \" from \" + upload.url);\n        }\n\n        resolve(upload);\n      };\n\n      var copyProp = function copyProp(obj, srcProp, destProp) {\n        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {\n          obj[destProp] = obj[srcProp];\n        }\n      };\n      /** @type {Record<string, string>} */\n\n\n      var meta = {};\n      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.\n      : Object.keys(file.meta);\n      metaFields.forEach(function (item) {\n        meta[item] = file.meta[item];\n      }); // tusd uses metadata fields 'filetype' and 'filename'\n\n      copyProp(meta, 'type', 'filetype');\n      copyProp(meta, 'name', 'filename');\n      uploadOptions.metadata = meta;\n      var upload = new tus.Upload(file.data, uploadOptions);\n      _this2.uploaders[file.id] = upload;\n      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy); // Make `resume: true` work like it did in tus-js-client v1.\n      // TODO: Remove in @uppy/tus v2.\n\n      if (opts.resume) {\n        upload.findPreviousUploads().then(function (previousUploads) {\n          var previousUpload = previousUploads[0];\n\n          if (previousUpload) {\n            _this2.uppy.log(\"[Tus] Resuming upload of \" + file.id + \" started at \" + previousUpload.creationTime);\n\n            upload.resumeFromPreviousUpload(previousUpload);\n          }\n        });\n      }\n\n      var queuedRequest = _this2.requests.run(function () {\n        if (!file.isPaused) {\n          // Ensure this gets scheduled to run _after_ `findPreviousUploads()` returns.\n          // TODO: Remove in @uppy/tus v2.\n          Promise.resolve().then(function () {\n            upload.start();\n          });\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n\n\n        return function () {};\n      });\n\n      _this2.onFileRemove(file.id, function (targetFileID) {\n        queuedRequest.abort();\n\n        _this2.resetUploaderReferences(file.id, {\n          abort: !!upload.url\n        });\n\n        resolve(\"upload \" + targetFileID + \" was removed\");\n      });\n\n      _this2.onPause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          upload.abort();\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this2.requests.run(function () {\n            upload.start();\n            return function () {};\n          });\n        }\n      });\n\n      _this2.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        upload.abort();\n      });\n\n      _this2.onCancelAll(file.id, function () {\n        queuedRequest.abort();\n\n        _this2.resetUploaderReferences(file.id, {\n          abort: !!upload.url\n        });\n\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n\n      _this2.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n\n        if (file.error) {\n          upload.abort();\n        }\n\n        queuedRequest = _this2.requests.run(function () {\n          upload.start();\n          return function () {};\n        });\n      });\n    }).catch(function (err) {\n      _this2.uppy.emit('upload-error', file, err);\n\n      throw err;\n    });\n  }\n  /**\n   * @param {UppyFile} file for use with upload\n   * @param {number} current file in a queue\n   * @param {number} total number of files in a queue\n   * @returns {Promise<void>}\n   */\n  ;\n\n  _proto.uploadRemote = function uploadRemote(file, current, total) {\n    var _this3 = this;\n\n    this.resetUploaderReferences(file.id);\n\n    var opts = _extends({}, this.opts);\n\n    if (file.tus) {\n      // Install file-specific upload overrides.\n      _extends(opts, file.tus);\n    }\n\n    this.uppy.emit('upload-started', file);\n    this.uppy.log(file.remote.url);\n\n    if (file.serverToken) {\n      return this.connectToServerSocket(file);\n    }\n\n    return new Promise(function (resolve, reject) {\n      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n      var client = new Client(_this3.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet\n\n      client.post(file.remote.url, _extends({}, file.remote.body, {\n        endpoint: opts.endpoint,\n        uploadUrl: opts.uploadUrl,\n        protocol: 'tus',\n        size: file.data.size,\n        headers: opts.headers,\n        metadata: file.meta\n      })).then(function (res) {\n        _this3.uppy.setFileState(file.id, {\n          serverToken: res.token\n        });\n\n        file = _this3.uppy.getFile(file.id);\n        return _this3.connectToServerSocket(file);\n      }).then(function () {\n        resolve();\n      }).catch(function (err) {\n        _this3.uppy.emit('upload-error', file, err);\n\n        reject(err);\n      });\n    });\n  }\n  /**\n   * See the comment on the upload() method.\n   *\n   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().\n   *\n   * @param {UppyFile} file\n   */\n  ;\n\n  _proto.connectToServerSocket = function connectToServerSocket(file) {\n    var _this4 = this;\n\n    return new Promise(function (resolve, reject) {\n      var token = file.serverToken;\n      var host = getSocketHost(file.remote.companionUrl);\n      var socket = new Socket({\n        target: host + \"/api/\" + token,\n        autoOpen: false\n      });\n      _this4.uploaderSockets[file.id] = socket;\n      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);\n\n      _this4.onFileRemove(file.id, function () {\n        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion\n        // @todo don't send pause event in the next major release.\n\n        socket.send('pause', {});\n        socket.send('cancel', {});\n\n        _this4.resetUploaderReferences(file.id);\n\n        resolve(\"upload \" + file.id + \" was removed\");\n      });\n\n      _this4.onPause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          socket.send('pause', {});\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this4.requests.run(function () {\n            socket.send('resume', {});\n            return function () {};\n          });\n        }\n      });\n\n      _this4.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        socket.send('pause', {});\n      });\n\n      _this4.onCancelAll(file.id, function () {\n        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion\n        // @todo don't send pause event in the next major release.\n\n        socket.send('pause', {});\n        socket.send('cancel', {});\n\n        _this4.resetUploaderReferences(file.id);\n\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n\n      _this4.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n\n        if (file.error) {\n          socket.send('pause', {});\n        }\n\n        queuedRequest = _this4.requests.run(function () {\n          socket.send('resume', {});\n          return function () {};\n        });\n      });\n\n      _this4.onRetry(file.id, function () {\n        // Only do the retry if the upload is actually in progress;\n        // else we could try to send these messages when the upload is still queued.\n        // We may need a better check for this since the socket may also be closed\n        // for other reasons, like network failures.\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n\n      _this4.onRetryAll(file.id, function () {\n        // See the comment in the onRetry() call\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n\n      socket.on('progress', function (progressData) {\n        return emitSocketProgress(_this4, progressData, file);\n      });\n      socket.on('error', function (errData) {\n        var message = errData.error.message;\n\n        var error = _extends(new Error(message), {\n          cause: errData.error\n        }); // If the remote retry optimisation should not be used,\n        // close the socket—this will tell companion to clear state and delete the file.\n\n\n        if (!_this4.opts.useFastRemoteRetry) {\n          _this4.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.\n\n\n          _this4.uppy.setFileState(file.id, {\n            serverToken: null\n          });\n        } else {\n          socket.close();\n        }\n\n        _this4.uppy.emit('upload-error', file, error);\n\n        queuedRequest.done();\n        reject(error);\n      });\n      socket.on('success', function (data) {\n        var uploadResp = {\n          uploadURL: data.url\n        };\n\n        _this4.uppy.emit('upload-success', file, uploadResp);\n\n        _this4.resetUploaderReferences(file.id);\n\n        queuedRequest.done();\n        resolve();\n      });\n\n      var queuedRequest = _this4.requests.run(function () {\n        socket.open();\n\n        if (file.isPaused) {\n          socket.send('pause', {});\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n        // Also, we need to remove the request from the queue _without_ destroying everything\n        // related to this upload to handle pauses.\n\n\n        return function () {};\n      });\n    });\n  }\n  /**\n   * Store the uploadUrl on the file options, so that when Golden Retriever\n   * restores state, we will continue uploading to the correct URL.\n   *\n   * @param {UppyFile} file\n   * @param {string} uploadURL\n   */\n  ;\n\n  _proto.onReceiveUploadUrl = function onReceiveUploadUrl(file, uploadURL) {\n    var currentFile = this.uppy.getFile(file.id);\n    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.\n\n    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {\n      this.uppy.log('[Tus] Storing upload url');\n      this.uppy.setFileState(currentFile.id, {\n        tus: _extends({}, currentFile.tus, {\n          uploadUrl: uploadURL\n        })\n      });\n    }\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(string): void} cb\n   */\n  ;\n\n  _proto.onFileRemove = function onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', function (file) {\n      if (fileID === file.id) cb(file.id);\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(boolean): void} cb\n   */\n  ;\n\n  _proto.onPause = function onPause(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {\n      if (fileID === targetFileID) {\n        // const isPaused = this.uppy.pauseResume(fileID)\n        cb(isPaused);\n      }\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onRetry = function onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onRetryAll = function onRetryAll(fileID, cb) {\n    var _this5 = this;\n\n    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {\n      if (!_this5.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onPauseAll = function onPauseAll(fileID, cb) {\n    var _this6 = this;\n\n    this.uploaderEvents[fileID].on('pause-all', function () {\n      if (!_this6.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onCancelAll = function onCancelAll(fileID, cb) {\n    var _this7 = this;\n\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this7.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {string} fileID\n   * @param {function(): void} cb\n   */\n  ;\n\n  _proto.onResumeAll = function onResumeAll(fileID, cb) {\n    var _this8 = this;\n\n    this.uploaderEvents[fileID].on('resume-all', function () {\n      if (!_this8.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  /**\n   * @param {(UppyFile | FailedUppyFile)[]} files\n   */\n  ;\n\n  _proto.uploadFiles = function uploadFiles(files) {\n    var _this9 = this;\n\n    var promises = files.map(function (file, i) {\n      var current = i + 1;\n      var total = files.length;\n\n      if ('error' in file && file.error) {\n        return Promise.reject(new Error(file.error));\n      }\n\n      if (file.isRemote) {\n        // We emit upload-started here, so that it's also emitted for files\n        // that have to wait due to the `limit` option.\n        // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n        if (!file.progress.uploadStarted || !file.isRestored) {\n          _this9.uppy.emit('upload-started', file);\n        }\n\n        return _this9.uploadRemote(file, current, total);\n      } // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n\n\n      if (!file.progress.uploadStarted || !file.isRestored) {\n        _this9.uppy.emit('upload-started', file);\n      }\n\n      return _this9.upload(file, current, total);\n    });\n    return settle(promises);\n  }\n  /**\n   * @param {string[]} fileIDs\n   */\n  ;\n\n  _proto.handleUpload = function handleUpload(fileIDs) {\n    var _this10 = this;\n\n    if (fileIDs.length === 0) {\n      this.uppy.log('[Tus] No files to upload');\n      return Promise.resolve();\n    }\n\n    if (this.opts.limit === 0) {\n      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');\n    }\n\n    this.uppy.log('[Tus] Uploading...');\n    var filesToUpload = fileIDs.map(function (fileID) {\n      return _this10.uppy.getFile(fileID);\n    });\n    return this.uploadFiles(filesToUpload).then(function () {\n      return null;\n    });\n  };\n\n  _proto.install = function install() {\n    this.uppy.setState({\n      capabilities: _extends({}, this.uppy.getState().capabilities, {\n        resumableUploads: true\n      })\n    });\n    this.uppy.addUploader(this.handleUpload);\n    this.uppy.on('reset-progress', this.handleResetProgress);\n\n    if (this.opts.autoRetry) {\n      this.uppy.on('back-online', this.uppy.retryAll);\n    }\n  };\n\n  _proto.uninstall = function uninstall() {\n    this.uppy.setState({\n      capabilities: _extends({}, this.uppy.getState().capabilities, {\n        resumableUploads: false\n      })\n    });\n    this.uppy.removeUploader(this.handleUpload);\n\n    if (this.opts.autoRetry) {\n      this.uppy.off('back-online', this.uppy.retryAll);\n    }\n  };\n\n  return Tus;\n}(Plugin), _class.VERSION = \"1.9.1\", _temp);"]},"metadata":{},"sourceType":"script"}